import { Injectable, Inject, PLATFORM_ID } from '@angular/core';
import { HTTP_INTERCEPTORS, HttpClient, HttpHeaders } from '@angular/common/http';
import { isPlatformBrowser } from '@angular/common';
import { catchError, forkJoin, map, Observable, of, switchMap, tap, throwError } from 'rxjs';
import * as CryptoJS from 'crypto-js';
import { environment } from '../../environments/environment';

import { LoginComponent } from '../components/login/login.component';
import { UsersComponent } from '../components/settings-group/users/users.component';
import { AuthInterceptor } from './token-interceptor';
import { response } from 'express';

export interface User {
id: number;
username: string;
email: string;
nickname: string;
password: string;
deviceID: number ;
userName :string;
SecretKey :string ;
TwoFactorCode:string;
token?:string ;

};





@Injectable({
providedIn: 'root',
})

export class UserService {
// Base URL for your API (defined in environment.ts / environment.prod.ts)
private apiURL: string = environment.APIURL;
private OTPURL: string = environment.OTPURL;

// twoFactorCode:string='';
// TwoFactorCode=this.twoFactorCode;



// Key used for storing user session info in localStorage
private currentUserKey = 'currentUser';

constructor(
@Inject(PLATFORM_ID) private platformId: Object,
private http: HttpClient
) {}


getUsers(): Observable<User[]> {
  return this.http.get<User[]>(this.apiURL + 'users', {

  });
  }


getUserByUsernameAndPassword(
username: string,
password: string,
deviceID: number = 123456
): Observable<User | null> {
// Hash the password locally before sending.
const hashedPassword = CryptoJS.SHA256(password).toString();
const token = localStorage.getItem('token');
// أو: const token = localStorage.getItem('token');
const headers = new HttpHeaders({
  'Content-Type': 'application/json',
  'Access-Control-Allow-Origin': '*',
  'Accept': 'application/json',
  'Authorization': `Bearer ${token}`

});
return this.http.post<User | null>(this.apiURL + 'login', {
username,
password,
hashedPassword,
deviceID,
},{headers,responseType:"text" as "json" , observe:"response" as 'body' })
// .pipe(
// map((response: any) => {
//   console.log('Login response:', response);
// if (response && response.token) {
//   localStorage.setItem('token', response.token);
//   localStorage.setItem('userId', response.userId.toString());
//   return response as User;
// } else {
//   console.error('No token in response');
//   return null;
// }

// }))

}

verifyTOTP(code: string, userId: number): Observable<{ valid: boolean }> {
  const token = localStorage.getItem('token'); // تأكد من أن هذا السطر يعمل بشكل صحيح
  console.log('Token in verifyTOTP:', token); // أضف هذا للتحقق من قيمة التوكن

  const headers = new HttpHeaders({
    'Content-Type': 'application/json',
    'Access-Control-Allow-Origin': '*',
    'Accept': 'application/json',
    'Authorization': `Bearer ${token}`
  });

  return this.http.post<{ valid: boolean }>(
    `${environment.OTPURL2}`,
    {

      token:'',
      code: code,
      userId: userId,
    },
    {headers,responseType:"test" as "json"}
  );}

login(data: any) {
  const headers = new HttpHeaders({
    'Content-Type': 'application/json',
    'Access-Control-Allow-Origin': '*',
    'Accept': 'application/json',
  });


  return this.http.post<any>('http://api-ocr.egcloud.gov.eg/login', data, { headers, responseType: 'json' as 'json' })
    .pipe(
      // Optionally, handle the response directly here if you need
      tap(response => {
        console.log(response , " res")
        // Assuming the token is in response.token (adjust based on actual response structure)
        if (response && response.token) {
          localStorage.setItem('auth_token', response.token);  // Store token in localStorage
        }
      })
    );
}


//  // Add user to main API
//  addUserToMainAPI(user: User): Observable<any> {
//   const hashedPassword = CryptoJS.SHA256(user.password).toString();
//   const mainAPIUser = {
//     username: user.username,
//     email: user.email,
//     nickname: user.nickname,
//     password: hashedPassword,
//     deviceID: user.deviceID
//   };

//   return this.http.post(`${environment.APIURL}users`, mainAPIUser);
// }


// // Add user to OTP API
// addUserToOTPAPI(user: User): Observable<any> {
//   const otpUser = {
//     UserName: user.username,
    // Password: user.password,
//     SecretKey: '', // Will be generated by backend
//     TwoFactorCode: '' // Will be generated by backend
//   };

//   return this.http.post(`${environment.OTPURL}`, otpUser);
// }





 // Add user to main API
 addUserToMainAPI(user: User): Observable<any> {
  const hashedPassword = CryptoJS.SHA256(user.password).toString();

  const mainAPIUser = {
    username: user.username,
    email: user.email,
    nickname: user.nickname,
    password: hashedPassword,
    deviceID: user.deviceID
  };

  // Add headers if needed
  const headers = {
    'Content-Type': 'application/json',
    'Access-Control-Allow-Origin': '*',
    'Accept': 'application/json'
  };

  return this.http.post(
    `${this.apiURL}users`,
    mainAPIUser,
    {headers,responseType:"test" as "json" , observe:"response" as "body"}
  ).pipe(
    catchError(error => {
      console.error('Error in addUserToMainAPI:', error);
      return throwError(() => new Error('Failed to add user to main API'));
    })
  );
}



// دالة لتوليد كود المصادقة الثنائية (6 أرقام عشوائية)
private generateRandomTwoFactorCode(): string {
  // توليد رقم عشوائي من 6 خانات
  return Math.floor(100000 + Math.random() * 900000).toString();
}


// Add user to OTP API
addUserToOTPAPI(user: User): Observable<any> {
  const otpUser = {
    userName: user.username,
    password: user.password, // Consider if you need hashed password here
    SecretKey: '', // Will be generated by backend
    TwoFactorCode: '' // Will be generated by backend
  };

  // Add headers if needed
  const headers = {
    'Content-Type': 'application/json'
  };

  return this.http.post(
    `${this.OTPURL}`,
    otpUser,
    {headers}
  )
  .pipe(
    catchError(error => {
      console.error('Error in addUserToOTPAPI:', error);
      return throwError(() => new Error('Failed to add user to OTP API'));
    })
  );
}



// Reset OTP for user
resetOTP(username: string): Observable<any> {
  return this.http
    .post(`${this.OTPURL}/reset`, { userName: username })
    .pipe(
      catchError(error => {
        console.error('Error resetting OTP:', error);
        return throwError(() => new Error('Failed to reset OTP'));
      })
    );
}


// Combined method to add user to both APIs
addUserToBothAPIs(user: User): Observable<any> {
  return forkJoin({
    mainAPI: this.addUserToMainAPI(user),
    otpAPI: this.addUserToOTPAPI(user)
  }).pipe(
    map(response => ({
      mainAPIResponse: response.mainAPI,
      otpAPIResponse: response.otpAPI
    })),
    catchError(error => {
      console.error('Error in addUserToBothAPIs:', error);
      return throwError(() => new Error('Failed to add user to one or both APIs'));
    })
  );
}

// Sequential version of adding to both APIs
addUserToBothAPIsSequential(user: User): Observable<any> {
  return this.addUserToMainAPI(user).pipe(
    switchMap(mainAPIResponse => {
      return this.addUserToOTPAPI(user).pipe(
        map(otpAPIResponse => ({
          mainAPIResponse,
          otpAPIResponse
        }))
      );
    }),
    catchError(error => {
      console.error('Error in addUserToBothAPIsSequential:', error);
      return throwError(() => new Error('Failed to add user to one or both APIs'));
    })
  );
}



updateUser(userToUpdate: User): Observable<any> {
// Hash the password if you always want to ensure it’s stored hashed
const hashedPassword = CryptoJS.SHA256(userToUpdate.password).toString();
const updatedUser = { ...userToUpdate, password: hashedPassword };


return this.http.put<User>(`${this.apiURL}users/${userToUpdate.id}`, updatedUser);
}


deleteUser(userId: number): Observable<any> {
return this.http.delete(this.apiURL + 'users' +  './${userId}');
}


// Store the currently logged-in user in localStorage
setCurrentUser(user: User): void {
if (isPlatformBrowser(this.platformId)) {
localStorage.setItem(this.currentUserKey, JSON.stringify(user));
}
}

// Retrieve the currently logged-in user
getCurrentUser(): User | null {
if (isPlatformBrowser(this.platformId)) {
const storedUser = localStorage.getItem(this.currentUserKey);
return storedUser ? JSON.parse(storedUser) : null;
}
return null;
}

// Check if any user is logged in
isLoggedIn(): boolean {
return this.getCurrentUser() !== null;
}

// Log out the currently logged-in user
logout(): void {
if (isPlatformBrowser(this.platformId)) {
localStorage.removeItem(this.currentUserKey);
}
}







  getUserById(userId: number): Observable<User> {
    return this.http.get<User>(`${this.OTPURL}/${userId}`);
  }
                    
  enableTwoFactorAuth(userId: number): Observable<{ qrCodeImage: string; secretKey: string }> {
    return this.http.post<{ qrCodeImage: string; secretKey: string }>(
      `${this.OTPURL}/${userId}/enable-2fa`, 
      {}
    );
  }

  disableTwoFactorAuth(userId: number): Observable<any> {
    return this.http.post(`${this.OTPURL}/${userId}/disable-2fa`, {});
  }

  verifyTwoFactorAuth(userId: number, otp: string): Observable<any> {
    return this.http.post(`${this.OTPURL}/${userId}/verify-2fa`, { otp });
  }



// دالة للتحقق من الرمز (TOTP) الذي أدخله المستخدم
// يُفترض أن الـ Backend لديه Endpoint اسمه "/verify-totp"
// يستقبل { code, userId } أو حسب ما ترغبين.
}
